{-# LANGUAGE LambdaCase #-}
module Rules.ToolArgs(toolArgsTarget) where

import qualified Rules.Generate
import Development.Shake
import Target
import Context
import Stage
import Expression

import Packages
import Settings
import Hadrian.Oracles.Cabal
import Hadrian.Haskell.Cabal.Type
import System.Directory (canonicalizePath)
import System.Environment (lookupEnv)

-- | @tool:@ is used by tooling in order to get the arguments necessary
-- to set up a GHC API session which can compile modules from GHC. When
-- run, the target prints out the arguments that would be passed to @ghc@
-- during normal compilation to @stdout@ for the file passed as an
-- argument.
--
-- This target is called by the `ghci.sh` script in order to load all of GHC's
-- modules into GHCi. It is invoked with argument `tool:ghc/Main.hs` in
-- that script so that we can load the whole library and executable
-- components into GHCi.
--
-- In the future where we have multi-component ghci this code can be
-- modified to supply the right arguments for that. At the moment it is
-- also used for GHC's support for multi-component ghcide (see the
-- `hadrian/hie-bios` script).


-- | A phony target of form `tool:path/to/file.hs` which returns the
-- options needed to compile the specific file.
toolArgsTarget :: Rules ()
toolArgsTarget = do
  phonys (\s -> if "tool:" `isPrefixOf` s then Just (toolRuleBody (drop 5 s)) else Nothing)

toolRuleBody :: FilePath -> Action ()
toolRuleBody fp = do
  mm <- dirMap
  cfp <- liftIO $ canonicalizePath fp
  case find (flip isPrefixOf cfp . fst) mm  of
    Just (_, p) -> mkToolTarget p
    Nothing -> fail $ "No prefixes matched " ++ show fp ++ " IN\n " ++ show mm

mkToolTarget :: Package -> Action ()
mkToolTarget p = do
    -- This builds automatically generated dependencies. Not sure how to do
    -- this generically yet.
    allDeps
    setupConfig <- pkgSetupConfigFile (Context Stage0 p (if windowsHost then vanilla else dynamic))
    need [setupConfig]
    let ctx = Context Stage0 p (if windowsHost then vanilla else dynamic)
        fake_target = target ctx
                        (Ghc ToolArgs Stage0) [] ["ignored"]

    cd <- readContextData ctx
    let es = modules cd ++ otherModules cd

    arg_list <- interpret fake_target getArgs
    liftIO $ lookupEnv "TOOL_OUTPUT" >>= \case
      Nothing -> putStrLn (intercalate "\n" (arg_list ++ es))
      Just out -> writeFile out (intercalate "\n" (arg_list ++ es))

allDeps :: Action ()
allDeps = do
   do
    -- We can't build DLLs on Windows (yet). Actually we should only
    -- include the dynamic way when we have a dynamic host GHC, but just
    -- checking for Windows seems simpler for now.
    let fake_target = target (Context Stage0 compiler (if windowsHost then vanilla else dynamic))
                             (Ghc ToolArgs Stage0) [] ["ignored"]

    -- need the autogenerated files so that they are precompiled
    interpret fake_target Rules.Generate.compilerDependencies >>= need

    root <- buildRoot
    let dir = buildDir (vanillaContext Stage0 compiler)
    need [ root -/- dir -/- "GHC" -/- "Parser.hs" ]
    need [ root -/- dir -/- "GHC" -/- "Parser" -/- "Lexer.hs" ]
    need [ root -/- dir -/- "GHC" -/- "Cmm" -/- "Parser.hs" ]
    need [ root -/- dir -/- "GHC" -/- "Cmm" -/- "Lexer.hs"  ]

-- | Create a mapping from files to which component it belongs to.
dirMap :: Action [(FilePath, Package)]
dirMap = do
  targets <- stagePackages Stage0
  forM [(pkgPath p, p) | p <- targets] $ \(path, p) -> liftIO $ do
    path' <- canonicalizePath path
    pure (path', p)
